pipeline {
    agent any

    triggers {
        githubPush()
    }

    environment {
        SERVICE_DIR     = 'server/heartbeat_service'
        IMAGE_NAME      = 'heartbeat-service:latest'
        CONTAINER_NAME  = 'heartbeat-service'
        DOCKERFILE_PATH = 'dockerfile'
        SHOULD_BUILD    = 'true'
    }

    options {
        timestamps()
    }

    stages {
        stage('Preparation') {
            steps {
                script {
                    env.SERVICE_DIR = fileExists('server/heartbeat_service/pom.xml') ? 'server/heartbeat_service' : 'heartbeat_service'

                    def candidatePaths = [env.SERVICE_DIR]
                    if (env.SERVICE_DIR.startsWith('server/')) {
                        candidatePaths << env.SERVICE_DIR.replaceFirst('^server/', '')
                    } else {
                        candidatePaths << "server/${env.SERVICE_DIR}"
                    }
                    candidatePaths = candidatePaths.collect { it.replaceFirst('^\\./', '') }.unique()

                    def causes = currentBuild.rawBuild?.getCauses() ?: []
                    def manualTrigger = causes.any { it.class.simpleName == 'UserIdCause' }

                    def changedFilesRaw = ''
                    try {
                        def previousCommit = env.GIT_PREVIOUS_SUCCESSFUL_COMMIT ?: env.GIT_PREVIOUS_COMMIT
                        def diffCmd = previousCommit ? "git diff --name-only ${previousCommit} HEAD" : "git show --pretty='' --name-only HEAD"
                        changedFilesRaw = sh(script: diffCmd, returnStdout: true).trim()
                    } catch (Exception ex) {
                        echo "偵測變更檔案時發生錯誤：${ex.message}"
                    }
                    def changedFiles = changedFilesRaw ? changedFilesRaw.readLines().findAll { it?.trim() } : []

                    boolean shouldBuild = manualTrigger
                    if (!manualTrigger) {
                        shouldBuild = changedFiles.any { path ->
                            def normalized = path.replaceFirst('^\\./', '')
                            candidatePaths.any { prefix -> normalized == prefix || normalized.startsWith("${prefix}/") }
                        }
                    }

                    env.SHOULD_BUILD = shouldBuild.toString()

                    if (shouldBuild) {
                        if (manualTrigger && changedFiles.isEmpty()) {
                            echo "手動觸發：強制執行 ${env.SERVICE_DIR} 建置流程。"
                        } else {
                            echo "變更偵測：${env.SERVICE_DIR} 有相關更新，將執行建置流程。"
                        }
                    } else {
                        echo "變更偵測：${env.SERVICE_DIR} 無相關變更，本次僅執行檢查步驟。"
                    }
                }
            }
        }

        stage('Unit Tests') {
            when {
                expression { env.SHOULD_BUILD?.toBoolean() }
            }
            steps {
                dir(env.SERVICE_DIR) {
                    sh 'chmod +x mvnw'
                    sh './mvnw -B clean verify'
                }
            }
        }

        stage('Build Docker Image') {
            when {
                expression { env.SHOULD_BUILD?.toBoolean() }
            }
            steps {
                dir(env.SERVICE_DIR) {
                    sh "docker build --pull -t ${IMAGE_NAME} -f ${DOCKERFILE_PATH} ."
                }
            }
        }

        stage('Deploy') {
            when {
                expression { env.SHOULD_BUILD?.toBoolean() }
            }
            steps {
                dir(env.SERVICE_DIR) {
                    sh "docker container rm -f ${CONTAINER_NAME} || true"
                    sh "docker run -d --name ${CONTAINER_NAME} --network host --restart unless-stopped ${IMAGE_NAME}"
                }
            }
        }
    }
}
